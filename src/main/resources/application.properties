# Application Configuration
spring.application.name=spring

# ============================================================================
# SPRING PROFILES CONFIGURATION
# ============================================================================
# Default profile: dev (for local development)
# Override via environment variable: SPRING_PROFILES_ACTIVE=prod
# Or via command line: --spring.profiles.active=prod
# 
# Available profiles:
#   - dev: Development/local testing (default)
#   - prod: Production server deployment
#   - test: Testing environment (for unit/integration tests)
#
# Profile-specific configurations:
#   - application-dev.properties: Development settings
#   - application-prod.properties: Production settings
#   - application-test.properties: Test settings (if needed)
#
spring.profiles.active=${SPRING_PROFILES_ACTIVE:dev}

# ============================================================================
# PRIMARY DATABASE: PostgreSQL (Business Data)
# ============================================================================
# Values can be overridden by environment variables: POSTGRES_URL, POSTGRES_USERNAME, POSTGRES_PASSWORD
# IMPORTANT: POSTGRES_URL must be set via environment variable or .env file
# Default is set to localhost for development - override in production
# 
# NOTE: If POSTGRES_URL is not set, the application will fail to start.
# Make sure to set POSTGRES_URL in your .env file or as an environment variable.
# 
# IMPORTANT: When POSTGRES_URL is empty, Spring Boot may try to auto-configure H2.
# To prevent this, ensure POSTGRES_URL is set in your .env file.
spring.datasource.url=${POSTGRES_URL:}
spring.datasource.username=${POSTGRES_USERNAME:}
spring.datasource.password=${POSTGRES_PASSWORD:}
spring.datasource.driver-class-name=org.postgresql.Driver

# Disable H2 console (H2 is in classpath for tests but should not be used in main application)
spring.h2.console.enabled=false

# JPA/Hibernate Configuration (PostgreSQL)
spring.jpa.database=postgresql
# Hibernate will automatically detect PostgreSQL dialect from JDBC URL, no need to specify explicitly
# DO NOT set spring.jpa.database-platform or SPRING_JPA_DATABASE_PLATFORM - it will cause deprecation warnings
# spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
# Hibernate will automatically create/update schema based on entities
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
# Configure Hibernate to use Jackson for JSON serialization (Hibernate 7.x)
# This ensures ArrayList and Map objects are properly serialized to JSONB
spring.jpa.properties.hibernate.type.json.format_mapper=jackson
# Disable Open Session In View (OSIV) to prevent database queries during view rendering
# This is a best practice to avoid lazy loading issues and improve performance
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
# Suppress warnings about missing constraints/indexes during schema update
# These warnings occur when Hibernate tries to drop indexes that don't exist
# This is normal behavior with ddl-auto=update and can be safely ignored
logging.level.org.hibernate.orm.jdbc.warn=ERROR
# Suppress deprecation warning about PostgreSQLDialect (Hibernate auto-detects it from JDBC URL)
logging.level.org.hibernate.orm.deprecation=ERROR
# Suppress deprecation warning about PostgreSQLDialect (Hibernate auto-detects it from JDBC URL)
logging.level.org.hibernate.orm.deprecation=ERROR

# Connection Pool Configuration (HikariCP)
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.connection-timeout=20000

# ============================================================================
# FLYWAY CONFIGURATION (Database Migrations)
# ============================================================================
# Flyway disabled - using Hibernate DDL auto instead
spring.flyway.enabled=false

# ============================================================================
# SECONDARY DATABASE: MongoDB (Logs, Analytics, Audit)
# ============================================================================
# Values can be overridden by environment variables: MONGODB_URI, MONGODB_DATABASE, MONGODB_USERNAME, MONGODB_PASSWORD, MONGODB_AUTH_DATABASE
# 
# CONFIGURATION OPTIONS:
# Option 1: Set MONGODB_URI directly with credentials (recommended):
#   MONGODB_URI=mongodb://username:password@127.0.0.1:27017/console?authSource=admin
#
# Option 2: Set separate username/password (MongoDBConfig will construct URI):
#   MONGODB_USERNAME=console
#   MONGODB_PASSWORD=console_2025!
#   MONGODB_AUTH_DATABASE=console (optional, defaults to database name)
#
# Option 3: No authentication (local development only):
#   Leave MONGODB_URI empty or use: mongodb://127.0.0.1:27017/console
#
# NOTE: If MONGODB_URI is explicitly set, it takes precedence over username/password.
# If MONGODB_URI is not set but username/password are provided, MongoDBConfig will construct the URI.
spring.data.mongodb.uri=${MONGODB_URI:}
spring.data.mongodb.host=${MONGODB_HOST:127.0.0.1}
spring.data.mongodb.port=${MONGODB_PORT:27017}
spring.data.mongodb.database=${MONGODB_DATABASE:}
# MongoDB authentication (used by MongoDBConfig to construct URI if MONGODB_URI is not set)
spring.data.mongodb.username=${MONGODB_USERNAME:}
spring.data.mongodb.password=${MONGODB_PASSWORD:}
spring.data.mongodb.authentication-database=${MONGODB_AUTH_DATABASE:}

# MongoDB Connection Pool
spring.data.mongodb.max-connection-idle-time=0
spring.data.mongodb.max-connection-life-time=0
spring.data.mongodb.min-connection-per-host=0
spring.data.mongodb.max-connection-per-host=100
spring.data.mongodb.connections-per-host=100
spring.data.mongodb.threads-allowed-to-block-for-connection-multiplier=5

# ============================================================================
# REDIS CONFIGURATION (Cache, Sessions, Queues)
# ============================================================================
# Values can be overridden by environment variables: REDIS_HOST, REDIS_PORT, REDIS_PASSWORD
spring.data.redis.host=${REDIS_HOST:127.0.0.1}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.database=${REDIS_DATABASE:0}
spring.data.redis.timeout=2000

# Redis Connection Pool (Lettuce)
spring.data.redis.lettuce.pool.enabled=true
spring.data.redis.lettuce.pool.max-active=8
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=0
spring.data.redis.lettuce.pool.max-wait=-1

# ============================================================================
# PERMISSION CACHE CONFIGURATION
# ============================================================================
# Enable/disable permission caching
permissions.cache.enabled=${PERMISSIONS_CACHE_ENABLED:true}
# Cache TTL in seconds (default: 3600 = 1 hour)
permissions.cache.ttl=${PERMISSIONS_CACHE_TTL:3600}

# ============================================================================
# DEVELOPMENT/TESTING DATABASES (H2 - when needed)
# ============================================================================
# Uncomment below for H2 in-memory database (development/testing only)
# spring.datasource.url=jdbc:h2:mem:testdb
# spring.datasource.driver-class-name=org.h2.Driver
# spring.datasource.username=sa
# spring.datasource.password=
# spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# spring.jpa.hibernate.ddl-auto=create-drop
# spring.h2.console.enabled=true
# spring.h2.console.path=/h2-console

# ============================================================================
# JWT CONFIGURATION (Authentication)
# ============================================================================
# Values can be overridden by environment variables: JWT_SECRET, JWT_EXPIRATION
# JWT Secret Key (minimum 32 characters, use strong random key in production)
# Generate with: openssl rand -base64 32
jwt.secret=${JWT_SECRET:your-256-bit-secret-key-change-in-production-minimum-32-characters}
# JWT Access Token Expiration (in milliseconds, default: 900000 = 15 minutes)
jwt.expiration=${JWT_EXPIRATION:900000}
# JWT Refresh Token Expiration (in milliseconds, default: 604800000 = 7 days)
jwt.refresh.expiration=${JWT_REFRESH_EXPIRATION:604800000}

# ============================================================================
# PASSWORD RESET CONFIGURATION
# ============================================================================
# Password reset token expiration (in hours, default: 1 hour)
app.password-reset.expiration-hours=${PASSWORD_RESET_EXPIRATION_HOURS:1}
# Maximum password reset requests per hour per user (rate limiting, default: 3)
app.password-reset.max-requests-per-hour=${PASSWORD_RESET_MAX_REQUESTS_PER_HOUR:3}

# ============================================================================
# EMAIL VERIFICATION CONFIGURATION
# ============================================================================
# Email verification token expiration (in hours, default: 24 hours)
app.email-verification.expiration-hours=${EMAIL_VERIFICATION_EXPIRATION_HOURS:24}
# Maximum email verification requests per hour per user (rate limiting, default: 3)
app.email-verification.max-requests-per-hour=${EMAIL_VERIFICATION_MAX_REQUESTS_PER_HOUR:3}

# ============================================================================
# EMAIL SERVICE CONFIGURATION
# ============================================================================
# Values can be overridden by environment variables: SMTP_HOST, SMTP_PORT, SMTP_USERNAME, SMTP_PASSWORD
# SMTP Host (e.g., smtp.gmail.com, smtp.sendgrid.net)
spring.mail.host=${SMTP_HOST:smtp.gmail.com}
# SMTP Port (587 for TLS, 465 for SSL)
spring.mail.port=${SMTP_PORT:587}
# SMTP Username (usually your email address)
spring.mail.username=${SMTP_USERNAME:}
# SMTP Password (use app-specific password for Gmail)
spring.mail.password=${SMTP_PASSWORD:}
# Enable SMTP authentication (can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH)
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH:true}
# Enable STARTTLS (can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE)
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE:true}
# Require STARTTLS (can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED)
spring.mail.properties.mail.smtp.starttls.required=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_REQUIRED:true}
# Connection timeout (milliseconds, can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT)
spring.mail.properties.mail.smtp.connectiontimeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT:5000}
# Write timeout (milliseconds, can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT)
spring.mail.properties.mail.smtp.writetimeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT:5000}
# Timeout (milliseconds, can be overridden via SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT)
spring.mail.properties.mail.smtp.timeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT:5000}

# Email Configuration
# From email address (e.g., noreply@yourapp.com)
app.email.from=${EMAIL_FROM:noreply@yourapp.com}
# Frontend URL for email links (e.g., http://localhost:3000)
app.email.frontend-url=${EMAIL_FRONTEND_URL:http://localhost:3000}
# Application name for email templates
app.email.app-name=${EMAIL_APP_NAME:Console}

# ============================================================================
# FILE STORAGE CONFIGURATION
# ============================================================================
# Avatar File Storage
# Values can be overridden by environment variables: FILE_STORAGE_UPLOAD_DIR, FILE_STORAGE_BASE_URL, FILE_STORAGE_MAX_FILE_SIZE
# Upload directory for avatar files (relative to application root or absolute path)
app.file-storage.upload-dir=${FILE_STORAGE_UPLOAD_DIR:uploads/avatars}
# Base URL for serving avatar files
app.file-storage.base-url=${FILE_STORAGE_BASE_URL:http://localhost:8080/api/v1/files/avatars}
# Maximum avatar file size in bytes (default: 5MB = 5242880 bytes)
app.file-storage.max-file-size=${FILE_STORAGE_MAX_FILE_SIZE:5242880}

# ============================================================================
# MULTIPART FILE UPLOAD CONFIGURATION
# ============================================================================
# Spring Servlet Multipart Configuration
# Maximum file size for a single file upload (default: 10MB = 10485760 bytes)
# This must be >= app.file-storage.max-file-size
spring.servlet.multipart.max-file-size=${SPRING_SERVLET_MULTIPART_MAX_FILE_SIZE:10485760}
# Maximum request size for a multipart request (total size of all files + form data)
# Should be slightly larger than max-file-size to account for form data
spring.servlet.multipart.max-request-size=${SPRING_SERVLET_MULTIPART_MAX_REQUEST_SIZE:10485760}
# Enable multipart uploads (default: true)
spring.servlet.multipart.enabled=true

# Blog Cover Images File Storage
# Values can be overridden by environment variables: FILE_STORAGE_BLOG_COVERS_UPLOAD_DIR, FILE_STORAGE_BLOG_COVERS_BASE_URL
# Upload directory for blog cover images (relative to application root or absolute path)
app.file-storage.blog-covers.upload-dir=${FILE_STORAGE_BLOG_COVERS_UPLOAD_DIR:uploads/blog-covers}
# Base URL for serving blog cover images
app.file-storage.blog-covers.base-url=${FILE_STORAGE_BLOG_COVERS_BASE_URL:http://localhost:8080/api/v1/files/blog-covers}

# Thymeleaf Configuration (for email templates)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.cache=false

# ============================================================================
# STRIPE CONFIGURATION (Payment Provider)
# ============================================================================
# Values can be overridden by environment variables: STRIPE_SECRET_KEY, STRIPE_PUBLISHABLE_KEY, STRIPE_WEBHOOK_SECRET
# Stripe Secret Key (use sk_test_xxx for test mode, sk_live_xxx for production)
# Get from: https://dashboard.stripe.com/test/apikeys
stripe.secret-key=${STRIPE_SECRET_KEY:}
# Stripe Publishable Key (use pk_test_xxx for test mode, pk_live_xxx for production)
# Get from: https://dashboard.stripe.com/test/apikeys
stripe.publishable-key=${STRIPE_PUBLISHABLE_KEY:}
# Stripe Webhook Secret (for webhook signature verification)
# Leave empty for now - you'll get this when you set up webhooks
# For local development: Run 'stripe listen --forward-to localhost:8080/api/v1/webhooks/stripe' to get the secret
# For production: Get from Stripe Dashboard → Developers → Webhooks → Endpoint → Signing secret
stripe.webhook-secret=${STRIPE_WEBHOOK_SECRET:}

# ============================================================================
# CORS CONFIGURATION (Frontend Integration)
# ============================================================================
# Comma-separated list of allowed origins (frontend URLs)
# Default: localhost:3000 (Next.js default port) and localhost:3001
cors.allowed-origins=${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:3001,http://localhost:20251}
# Whether to allow credentials (cookies, authorization headers)
cors.allow-credentials=${CORS_ALLOW_CREDENTIALS:true}
# Max age for preflight requests (in seconds, default: 1 hour)
cors.max-age=${CORS_MAX_AGE:3600}

# ============================================================================
# SOCKET.IO CONFIGURATION (Real-Time Monitoring)
# ============================================================================
# Socket.IO server hostname (0.0.0.0 to bind to all interfaces)
socketio.hostname=${SOCKETIO_HOSTNAME:0.0.0.0}
# Socket.IO server port (default: 9092, separate from main app on 8080)
# Note: Socket.IO runs as a separate server, so it needs its own port
# Frontend should connect to this port for WebSocket connections
socketio.port=${SOCKETIO_PORT:9092}
# Socket.IO context path
socketio.context=${SOCKETIO_CONTEXT:/socket.io}
# Ping timeout in milliseconds (default: 60 seconds)
socketio.ping-timeout=${SOCKETIO_PING_TIMEOUT:60000}
# Ping interval in milliseconds (default: 25 seconds)
socketio.ping-interval=${SOCKETIO_PING_INTERVAL:25000}
# Maximum frame payload length in bytes (default: 10MB = 10485760 bytes)
# This controls the maximum size of a single WebSocket frame
socketio.max-frame-payload-length=${SOCKETIO_MAX_FRAME_PAYLOAD_LENGTH:10485760}
# Maximum HTTP buffer size in bytes (default: 10MB = 10485760 bytes)
# This controls the maximum size of HTTP polling messages
socketio.max-http-buffer-size=${SOCKETIO_MAX_HTTP_BUFFER_SIZE:10485760}

# ============================================================================
# IP GEOLOCATION CONFIGURATION
# ============================================================================
# Enable/disable IP geolocation feature (default: true)
ip.geolocation.enabled=${IP_GEOLOCATION_ENABLED:true}
# Primary IP geolocation provider (IPLOCALIZE or IPLOCATE)
ip.geolocation.provider.primary=${IP_GEOLOCATION_PROVIDER_PRIMARY:IPLOCALIZE}
# Enable fallback to secondary provider if primary fails (default: false)
ip.geolocation.enable-fallback=${IP_GEOLOCATION_ENABLE_FALLBACK:false}
# Fallback IP geolocation provider (optional, leave empty to disable)
ip.geolocation.provider.fallback=${IP_GEOLOCATION_PROVIDER_FALLBACK:}

# IPLocalize.com Configuration
# Enable/disable IPLocalize adapter (default: true)
ip.geolocation.provider.iplocalize.enabled=${IP_GEOLOCATION_IPLOCALIZE_ENABLED:true}
# IPLocalize.com base URL (default: https://iplocalize.com)
ip.geolocation.provider.iplocalize.base-url=${IP_GEOLOCATION_IPLOCALIZE_BASE_URL:https://iplocalize.com}
# Request timeout in milliseconds (default: 5000)
ip.geolocation.provider.iplocalize.timeout=${IP_GEOLOCATION_IPLOCALIZE_TIMEOUT:5000}
